#!/usr/bin/perl
#
# A perl script to start on a given regexp and stop on another
#
$name = $0; $name =~ s'.*/''; # remove path--like basename
$usage  = "usage:\n$name";
$usage .= "\t[ ( -on | -begin | -start ) start_regexp ] [ ( -off | -end | -stop ) stop_regexp ] [ -lead N -linger M | -context N ]";
$usage .= "\t[ N | N.. | ..M | N..M ]";
$usage .= "\t[ [ -file ] file1 file2 .. ]";

use strict;
use warnings;

my $debug = 0;
my $lines, $conf, $printing;
$lines->{remembered} = []; # lines hash will record things like number of lines printed, total number of lines, etc.
$lines->{printed}    = 0;  # lines hash will record things like number of lines printed, total number of lines, etc.
$lines->{total}      = 0;  # lines hash will record things like number of lines printed, total number of lines, etc.
$printing = $conf->{start_printing} || 0;

&parse_args(@ARGV);

if ($debug) {
	print "starts\n";
	print "set start  to '$start_regexp'\n" if ($start_regexp);
	print "set starts at: " . join(', ', keys %$starts) .	"\n";
	print "\nstops\n";
	print "set stop   to '$stop_regexp'\n" if ($stop_regexp);
	print "set stops  at: " . join(', ', keys %$stops) .	"\n";
	print "\nfiles?\n";
	print "$_\n" foreach (@ARGV);
	$debug = 0;
}

exit 0;

sub process_inde {
	my( $lines, $conf, 
while (<>) {
	$lines->{total}++;
	# First handle explict start or stop line numbers                                               # printing by line number, inclusive endpoints implicit

	if ( $printing ) {
		if ( 
		print; $lines->{printed}++;
		$printing = 0 if $stops->{$.};
		next;
	} elsif ($stops->{$.}) {
		print if ( $conf->{include_stops} );
		$printing = 0;
	} elsif ($starts->{$.}) {
		$printing = 1;
	}
	if ($printing) {
		if ( $_ =~ $stop_regexp ) {
			$lines->{stops}++;
			$printing--;											# printing needn't be a toggle, if we wanted 5 lines of context around each start
			if ( $printing or $including_stops ) {	                # either lingering or explicitly printing stop matches
				print "(1,$printing,$.): $_" if ($debug);
				print;
				$lines->{printed}++;
				while ( $printing and ( $_ = <> ) ) {               # lingering now
					if ( $_ =~ $start_regexp ) {
						$printing = 1;
						next MAINLOOP;
					} else {
						$printing--;
					}
					print "(2,$printing,$.): $_" if ($debug);
					print;
					$lines->{printed}++;
				}
				print "-" x 60 . "\n";
			}
		} else {
			print "(3,$printing,$.): $_" if ($debug);
			print;
			$lines->{printed}++;
		}
	} else {
		if ( $_ =~ $start_regexp ) {
			$lines->{starts}++;
			$printing = 1;
			if ($lead and @{$lines->{remembered}} ) {
				if ($debug) {
					print "(4,$printing,$.): $_" foreach ( @{$lines->{remembered}} );
					print "(5,$printing,$.): $_";
				}
				print foreach ( @{$lines->{remembered}} );
				print;
				$lines->{printed} += ( $#{$lines->{remembered}} + 1 );
			} elsif ($including_starts) {
				print "(6,$printing,$.): $_" if ($debug);
				print;
				$lines->{printed}++;
			}
		} else {
			print "(7,$printing,$.): $_" if ($debug);
			push ( @{$lines->{remembered}}, $_);
			if ( $#{$lines->{remembered}} > $lead ) {
				shift ( @{$lines->{remembered}} );		# maintain remembered lines pipe length
				$lines->{not_printed}++;
			}
		}
	}
}


sub parse_args_inde {

	my @args=('?','help','debug');
	my @help=('print this message','print this message','set debugging flag');

	push(@args,'on','start','begin','off','stop','end');
	push(@help,'regexp to trigger printing',
	           'regexp to trigger printing',
	           'regexp to trigger printing',
	           'regexp to terminate printing',
	           'regexp to terminate printing',
	           'regexp to terminate printing');

	push(@args,'lead','linger','context','file');
	push(@help,'# of lines to print before each print trigger',
	           '# of lines to print after each terminate trigger',
	           '# of lines to print before and after a trigger',
	           'name of file to add to list of files to scan');

	push(@args,'N','N..','..M','N..M');
	push(@help,"will print line N, ignoring start/stop regexp's",
	           "start printing at line N, will continue until something terminates it",
	           "will terminate printing at line M, ignoring start/stop regexp's",
	           "will print all lines between N and M ignoring all all regexp triggers");

	grep(s/^([^-])/-$1/,@args);

	use Text::Abbrev;

	my $abbrev = abbrev @args;

	while ( @ARGV >= 1 ) {
		if      ( ( $abbrev{$ARGV[0]} eq '-help' )
			 || (   $abbrev{$ARGV[0]} eq '-?'    ) ) {
			&help($MAIN::usage);
			shift(@ARGV);

		} elsif ( $abbrev{$ARGV[0]} eq '-debug' ) {
			$MAIN::debug = 1;
			print "user specified debugging flag set\n";
			shift(@ARGV);

		} elsif ( $abbrev{$ARGV[0]} eq '-on' or  $abbrev{$ARGV[0]} eq '-start' or  $abbrev{$ARGV[0]} eq '-begin' ) {
			$MAIN::start_regexp = qr($ARGV[1]);
			print "user specified '$start_regexp' as regexp to trigger printing\n" if ($debug);
			shift(@ARGV); shift(@ARGV);

		} elsif ( $abbrev{$ARGV[0]} eq '-off' or  $abbrev{$ARGV[0]} eq '-stop' or  $abbrev{$ARGV[0]} eq '-end' ) {
			$MAIN::stop_regexp = qr($ARGV[1]);
			print "user specified '$stop_regexp' as regexp to terminate printing\n" if ($debug);
			shift(@ARGV); shift(@ARGV);

		} elsif ( $abbrev{$ARGV[0]} eq '-lead' ) {
			$MAIN::lead = $ARGV[1];
			print "user specified '$lead' as number of lines to print before each trigger regexp\n" if ($debug);
			shift(@ARGV); shift(@ARGV);

		} elsif ( $abbrev{$ARGV[0]} eq '-linger' ) {
			$MAIN::linger = $ARGV[1];
			print "user specified '$linger' as number of lines to print after each terminate regexp\n" if ($debug);
			shift(@ARGV); shift(@ARGV);

		} elsif ( $abbrev{$ARGV[0]} eq '-context' ) {
			$MAIN::lead = $ARGV[1];
			print "user specified '$lead' as number of lines to print before each trigger regexp\n" if ($debug);
			print "and the as number of lines to print after each terminate regexp\n" if ($debug);
			shift(@ARGV); shift(@ARGV);

		} elsif ( $abbrev{$ARGV[0]} eq '-file' ) {
			push(@MAIN::files,"$ARGV[1]") if $ARGV[1];
			print "add 'ARGV[1]' to list of files to scan\n" if ($debug);
			shift(@ARGV); shift(@ARGV);

		} elsif ( $ARGV[0] =~ m'^-?(\d+)\.\.+(\d+)$' ) {                                    # N to M
			push( @$MAIN::ranges,{ start=>$1, end=>$2 } );
			print "user has requested printing of lines $1 to $2 inclusive\n" if ($debug);
			shift(@ARGV); shift(@ARGV);

		} elsif ( $ARGV[0] =~ m'^-?(\d+)\.\.+$' ) {                                         # N on
			push( @$MAIN::ranges,{ start=>$1, end=>undef } );
			print "user has requested printing of lines starting at $1\n" if ($debug);
			shift(@ARGV);

		} elsif ( $ARGV[0] =~ m'^-?\.\.+(\d+)$' ) {                                         #   to M
			push( @$MAIN::ranges,{ start=>undef, end=>$1 } );
			print "user has requested printing of lines up to $1\n" if ($debug);
			shift(@ARGV);

		} elsif ( $ARGV[0] =~ m'^-?(\d+)$' ) {                                              # just print line N
			push( @$MAIN::ranges,{ start=>$1, end=>$1 } );
			print "user has requested printing of line $1\n" if ($debug);
			shift(@ARGV);

		} else {
			warn("$MAIN::name: Unknown option '$ARGV[0]'; assuming file to scan...\n") if ($debug);
			push(@files,shift(@ARGV));
		}
	}  # end while
	@ARGV = @MAIN::files;
	if (@$ranges) { @$MAIN::ranges = sort { ( $MAIN::ranges->[$a]{start} <=> $MAIN::ranges->[$b]{start} ) || ( $MAIN::ranges->[$a]{end} <=> $MAIN::ranges->[$b]{end} ) } @$ranges }
}  # end parse_args

sub initialize {
  $conf->{linger} = 0;                        # how many lines to print after each stop-trigger
  $conf->{lead} = 0;						  # how many lines to print before each start-trigger
  $conf->{include_starts} = 1;                # print lines which trigger starts
  $conf->{include_stops} = 1;                 # print lines which trigger starts
  $conf->{allow_start_while_lingering} = 1;   # while lingering start events will be sought
  $conf->{start_printing} = 1;                # beginning state will be 'printing'
  $conf->{use_paired_triggers} = 1;           # triggers are forced in pairs,
                                              # all start triggers are examined when not 'printing'
                                              # only paired stop trigger will count when 'printing'
											  # alternatively, use independant triggers, whereby all stop triggers are active when in the 'printing' state
}

sub help {
	select(STDOUT); $|=1; $\=''; 
	print "$_[0]\n";
	if (@MAIN::help) {
		for ($arg=$[; $arg<=$#args; $arg++) {
			printf "%-16s\t%s\n", $args[$arg], $MAIN::help[$arg];
		}
	} else {
		for ($arg=$[; $arg<=$#args; $arg++) {
			print "$args[$arg]\t";
		}
		print "\n";
	}
	exit 1;
}

__END__

What should happen if...

1) no args
	onoff
2) Number ranges
	a) onoff 13
	b) onoff 4..
	c) onoff ..27
	d) onoff 4..27
3) regular expressions for starting, stopping
	a) onoff -start 'one'
	b) onoff 'one' 'teen'

Notes:
1) Lead, Linger and Context will only be allowed in numbered cases in the special Single Number case.
2) For now, only one regular expression or regular expression pair will be allowed.
3) Include starts and stops will be on by default.  May add way to change this behavior in the future.

4) Should starts and stops be independant or in pairs?
	a) Pairs allows for multiple different start-stop regexp's.  
	   Also, each trigger pair could have it's only lead or linger or both.
	b) Indepentant allows for more flexibility, like print all lines between 'Steve' and line 400.

5) Can a start trigger also be a stop trigger?
6) While lingering, should start conditions be searched for?



     1	one
     2	two
     3	three
     4	four
     5	five
     6	six
     7	seven
     8	eight
     9	nine
    10	ten
    11	eleven
    12	twelve
    13	thirteen
    14	fourteen
    15	fifteen
    16	sixteen
    17	seventeen
    18	eighteen
    19	nineteen
    20	twenty
    21	twenty one
    22	twenty two
    23	twenty three
    24	twenty four
    25	twenty five
    26	twenty six
    27	twenty seven
    28	twenty eight
    29	twenty nine
    30	thirty
    31	thirty one
    32	thirty two
    33	thirty three
    34	thirty four
    35	thirty five
    36	thirty six
    37	thirty seven
    38	thirty eight
    39	thirty nine
    40	forty
    41	forty one
    42	forty two
    43	forty three
    44	forty four
    45	forty five
    46	forty six
    47	forty seven
    48	forty eight
    49	forty nine
    50	fifty
    51	fifty one
    52	fifty two
    53	fifty three
    54	fifty four
    55	fifty five
    56	fifty six
    57	fifty seven
    58	fifty eight
    59	fifty nine
    60	sixty
    61	sixty one
    62	sixty two
    63	sixty three
    64	sixty four
    65	sixty five
    66	sixty six
    67	sixty seven
    68	sixty eight
    69	sixty nine
    70	seventy
    71	seventy one
    72	seventy two
    73	seventy three
    74	seventy four
    75	seventy five
    76	seventy six
    77	seventy seven
    78	seventy eight
    79	seventy nine
    80	eighty
    81	eighty one
    82	eighty two
    83	eighty three
    84	eighty four
    85	eighty five
    86	eighty six
    87	eighty seven
    88	eighty eight
    89	eighty nine
    90	ninety
    91	ninety one
    92	ninety two
    93	ninety three
    94	ninety four
    95	ninety five
    96	ninety six
    97	ninety seven
    98	ninety eight
    99	ninety nine
   100	hundred
   101	hundred one
   102	hundred two
   103	hundred three
   104	hundred four
   105	hundred five
   106	hundred six
   107	hundred seven
   108	hundred eight
   109	hundred nine
