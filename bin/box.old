#!/usr/bin/perl
#
# A perl filter to put a box around text.
#
#
$name = $0;
$name =~ s'.*/''; # remove path--like basename
$usage = "usage:\n$name [-corners|-clipped] [-starting starting_string]";
$usage.= "[[-vertical] vertical ]";
$usage.= "[[-horizontal] horizontal ]";

$char='_';
$starting='';

&parse_args;

@text=<>;

$lws=1024;
# find leading-white-space and longest line;
foreach $line (@text) {
  chomp $line;
  ($ws,$rol)=($line=~/^(\s*)(.*)$/);
  if ($lws) {
    $ws=length($ws);
    $lws=( $lws < $ws) ? $lws : $ws ;
  }
  $line_length=length($line);
  $max_length=($max_length>$line_length) ? $max_length : $line_length ;
}
print "$max_length -> ";
$max_length-=$lws;
print "$max_length\n";
$lws= " " x $lws;

# print first line of box
print $starting . $lws;
if ($corners) {
  print $ul . $horizontal x ($max_length+$lines_width-2) . $ur . "\n";
} else {
  print       $horizontal x ($max_length+$lines_width) . "\n";
}
# print   content  of box
foreach $line (@text) {
  chomp $line;
  if (($ws,$rol)=($line=~/^($lws)(.*)/) ) {
    $rol=$rol . " " x ($max_length-length($rol));
  } else {
    $ws=$lws;
    $rol=$rol . " " x ($max_length);
  }
  print $starting . $ws . $vertical . $rol . $vertical . "\n";
}
# print  last line of box
print $starting . $lws;
if ($corners) {
  print $ll . $horizontal x ($max_length+$lines_width-2) . $lr . "\n";
} else {
  print       $horizontal x ($max_length+$lines_width) . "\n";
}

exit 0;

sub parse_args {

  local(%abbrev)=();
  local($true,$false)=(1,0);

  @args=('?','help');
  @help=('print this message','print this message');

  push(@args,'clipped','corners','backspaces','vertical','horizontal','starting');
  push(@help,'use / and \ as corners for characters - and |',
             'use + corners for characters - and |',
             'use backspaces to make the underline character',
             'define vertical character',
             'define horizontal character',
	     'define string that will start each line');

  grep(s/^([^-])/-\1/,@args);

  push(@INC,'/usr/lib/perl',"$HOME/perllib");
  require("abbrev.pl");
  &abbrev(*abbrev, @args);

  # defaults
  $vertical='|';
  $horizontal='-';

  while ( @ARGV >= 1 ) {
    if      ( ($abbrev{$ARGV[0]} eq '-help' )
           || ($abbrev{$ARGV[0]} eq '-?' ) ) {
      do help($usage);
      shift(@ARGV);
    } elsif ( $abbrev{$ARGV[0]} eq '-backspaces' ) {
      $backspaces=1;
      shift(@ARGV);
    } elsif ( $abbrev{$ARGV[0]} eq '-vertical' ) {
      $vertical=$ARGV[1];
      shift(@ARGV); shift(@ARGV);
    } elsif ( $abbrev{$ARGV[0]} eq '-horizontal' ) {
      $horizontal=$ARGV[1];
      shift(@ARGV); shift(@ARGV);
    } elsif ( $abbrev{$ARGV[0]} eq '-starting' ) {
      $starting=$ARGV[1];
      shift(@ARGV); shift(@ARGV);
    } elsif ( $abbrev{$ARGV[0]} eq '-corners' ) {
      $corners=$true;
      $ur=$ll=$ul=$lr='+';
      shift(@ARGV);
    } elsif ( $abbrev{$ARGV[0]} eq '-clipped' ) {
      $corners=$true;
      $ur=$ll='\\';
      $ul=$lr='/';
      shift(@ARGV);
    } else {
      $vertical=$horizontal=$ARGV[0];
      shift(@ARGV);
    }
    print "$debug";
  }  # end while
  $lines_width= (2 * length($vertical));
}  # end parse_args

sub help {
  select(STDOUT); $|=1; $\=''; 
  print "@_[0]\n";
  if (@help) {
    for ($arg=$[; $arg<=$#args; $arg++) {
      printf "%-16s\t%s\n", $args[$arg], $help[$arg];
    }
  } else {
    for ($arg=$[; $arg<=$#args; $arg++) {
      print "$args[$arg]\t";
    }
    print "\n";
  }
  exit 1;
}
__END__

 This is some test text.
 With multiple lines, some short and some long.
 See.

 This is a single short line.


